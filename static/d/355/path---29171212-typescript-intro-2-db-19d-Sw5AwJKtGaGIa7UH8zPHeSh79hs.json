{"data":{"site":{"siteMetadata":{"title":"Jon's Blog","author":""}},"markdownRemark":{"id":"e4f71a4a-701c-5dc8-bbe8-ea9bd77fb1ba","excerpt":"INSTALL COMPILE 可以添加参数-w，即—watch。每当helloworld.ts文件保存时便自动编译helloworld.ts更新js文件。 在html中引用编译后的js文件即可。例如可以在浏览器的console中看到console.log的内容。 TypeScript是JavaScript…","html":"<p>INSTALL</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">npm install -g typescript</code></pre></div>\n<p>COMPILE</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">tsc helloworld.ts</code></pre></div>\n<p>可以添加参数-w，即—watch。每当helloworld.ts文件保存时便自动编译helloworld.ts更新js文件。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">tsc helloworld.ts -w</code></pre></div>\n<p>在html中引用编译后的js文件即可。例如可以在浏览器的console中看到console.log的内容。</p>\n<p>TypeScript是JavaScript的超集</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">npm install -g typescript\ntsc --version</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">cd ~/test\nmkdir ts-hello\ncd ts-hello\natom main.ts</code></pre></div>\n<p>声明方式，两种：var或let</p>\n<p>let声明的变量作用域更小，不能出块级作用域如for(let i = 0; i &#x3C; 5; i++)</p>\n<p>数据类型：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let a: number;\nlet b: boolean;\nlet c: string;\nlet d: any;\nlet e: number[] = [1, 2, 3];\nlet f: any[] = [1, true, &#39;a&#39;, false];\n\nlet strArr: string[];\nlet numArr: number[];\nlet boolArr: boolean[];\nlet strArr2: Array&amp;lt;string&amp;gt;;\nlet numArr2: Array&amp;lt;number&amp;gt;;\nlet boolArr2: Array&amp;lt;boolean&amp;gt;;\n\nlet strNumTuple: [string, number]; // 假如对这个变量赋值时，先num再str则会编译成js时报错；先str再num其后再加别的则不会报错。\n\nlet myVoid: void = undefined;\nlet myVoid2: void = null;\nlet myNull: null = null;\nlet myNull2: null = undefined;\nlet myUndefined: undefined = undefined;\nlet myUndefined2: undefined = null;</code></pre></div>\n<p>static type checking</p>\n<p>strong typing</p>\n<p>可以支持强类型声明，但不算强制，毕竟有js垫底</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let message;\nmessage = &#39;abc&#39;;</code></pre></div>\n<p>此时message是any类型</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let message = ‘abc’；</code></pre></div>\n<p>此时message是string类型</p>\n<p>string类型等特定类型时，输入 <code>message.</code> 编辑器可以提示对应stirng类型可用的方法</p>\n<p>any类型时没有提示，要得到提示，有两种方法：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let message;\nmessage = &#39;abc&#39;;\nlet endsWithC = (&lt;string&gt;message).endsWith(&#39;c&#39;);\nlet alternativeWay = (message as string).endWith(&#39;c&#39;);</code></pre></div>\n<p>这两种(<string>message).和(message as string).只改变编辑器的行为，不影响编译，message类型仍为any</p>\n<p>Enums</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">enum Direction {\n    Up = 1,\n    Down,\n    Left,\n    Right\n}</code></pre></div>\n<p>1到4，不声明1则0到3</p>\n<p>function</p>\n<p>可以指定参数和返回值的类型</p>\n<p>可以typeof检测类型</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let mySum = function(num1:any, num2: number):number{\n    if(typeof num1 == &#39;string&#39;){\n    num1 = parseInt(num1);\n    }\n    return num1 + num2;\n}</code></pre></div>\n<p>Arrow function</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let log = function(message){\n    console.log(message);\n}\n\nlet doLog = (message) =&gt; console.log(message);</code></pre></div>\n<p>Interfaces</p>\n<p>例如我们声明一个函数的参数时：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let drawPoint = (a, b, c, d, e, f, g) =&gt; {\n\n}</code></pre></div>\n<p>参数太多了，我们可以将其封装为对象，然后只传入一个对象即可</p>\n<p>调用函数时传入对象：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//声明时只有一个参数\nlet drawPoint = (point) =&gt; {\n\n}\n\n//调用时传入一个对象\ndrawPoint({\n    x: 1,\n    y: 2\n})</code></pre></div>\n<p>为避免传入的对象不符合要求，例如{name: ‘xxx’}，可进行inline annotation</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//声明时指定要求\nlet drawPoint = (point: {x: number, y: number}) =&gt; {\n\n}</code></pre></div>\n<p>这种声明指定了一种类似于mongoose中schema的东西，在mongoose中，schema相当于是定义model的模板和规范，指定model应该是什么样子的。</p>\n<p>这里也是通过{x: bumber, y: number}指定传入的point要长成什么样子</p>\n<p>可以将这种声明抽象出来，便于在其他函数中传入同样格式的对象</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//我们将之称为interface，惯例：interface命名每个单词都首字母大写\ninterface Point {\n    x: number,\n    y: number\n}\n\n//声明函数\nlet drawPoint = (point: Point) =&gt; {\n\n}\n\n//再声明一个函数\nlet getDistance = (pointA: Point, pointB: Point) =&gt; {\n\n}\n\n//调用函数\ndrawPoint({\n    x: 1,\n    y: 2\n})</code></pre></div>\n<p>interface即接口的意思</p>\n<p>将函数参数的格式要求封装为一个对象，并赋予这种对象一个专门的名字，即interface</p>\n<p>按照interface的要求声明变量，然后将此变量作为参数传入函数即可。</p>\n<p>额外再举个例子熟悉下</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">/* 原版\nfunction showTodo(todo: {title: string, text: string}){\n    console.log(todo.title + &#39;: &#39; + todo.text);\n};\n\nlet myTodo = {title: &#39;Trash&#39;, text: &#39;Take out trash&#39;};\n\nshowTodo(myTodo);\n*/\n\n// interface版\ninterface Todo{\n    title: string;\n    text: string;\n}\n\nfunction showTodo(todo: Todo){\n    console.log(todo.title + &#39;: &#39; + todo.text);\n}\n\nlet myTodo = {title:&#39;Trash&#39;, text: &#39;Take out trash&#39;}\n\nshowTodo(myTodo);</code></pre></div>\n<p>cohesion</p>\n<p>In computer programming, cohesion refers to the degree to which the elements inside a module belong togethor.</p>\n<p>In object-oriented programming, if the methods that serve a class tend to be similar in many aspects, then the class is said to have high cohesion.</p>\n<p>In a highly cohesive system, code readability and reusability is increased, while complexity is kept manageable.</p>\n<p>基于这一原则,我们希望将一系列紧密联系的variables(properties)和functions(methods)组织在一起</p>\n<p>在typescript中我们通过Class来实现</p>\n<p>class</p>\n<p>在mian.ts文件：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Point {\n    //\n    x: number;\n    y: number;\n\n    //这个函数可以不需要参数，可直接获得class内的x和y\n    draw(){\n    console.log(&#39;X: &#39; + this.x + &#39;, Y: &#39; + this.y);\n    }\n\n    getDistance(another: Point){\n\n    }\n}\n\n/*\n//注意这种奇怪的声明方式,Point这个class相当于是自定义的type，而一下语句实在声明一个变量point并指定其type为自定义的Point Class\nlet point: Point;\n//但只有这个声明我们是无法运行下列方法的，此时会返回“TypeError: Cannot read property &#39;draw&#39; of undefined”\npoint.draw();\n//要这样\nlet point: Point = new Point();\n//或省略\nlet point = new Point();\n*/\n\n//实例化\nlet point = new Point();\n//调用\npoint.draw();</code></pre></div>\n<p>然后命令行执行：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">tsc main.ts //转译为js\nnode mian.js //运行js</code></pre></div>\n<p>输出结果：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">X: undefined, Y: undefined</code></pre></div>\n<p>如何赋值呢？可以在实例化后加上：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">point.x = 1;\npoint.x = 2;</code></pre></div>\n<p>命令行输入: <code>tsc main.ts &#x26;&#x26; node mian.js</code></p>\n<p>执行结果：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">X: 1, Y: 2</code></pre></div>\n<p>全都要创建完实例后一个一个添加吗？创建实例时直接建筑好不就行了。HOW？使用constructor</p>\n<p>constuctor</p>\n<p>当进行实例化时，会调用constructor方法</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//声明类\nclass Point {\n    //Fields\n    x: number;\n    y: number;\n\n    //声明构造器\n    constructor(x: number, y: number){\n    this.x = x;\n    this.y = y;\n    };\n\n    draw(){\n    console.log(&#39;X: &#39; + this.x + &#39;, Y: &#39; + this.y);\n    }\n}\n\n//实例化\nlet point = new Point(1, 2);\n\n//调用方法\npoint.draw();</code></pre></div>\n<p>此时，指定的两个参数必须提供，若 <code>let point = new Point();</code>则会报错。</p>\n<p>如何改善呢？Typescript不能有多个构造器。</p>\n<p>指定参数可选，方法如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">constructor(x?: number, y?: number){\n\n}</code></pre></div>\n<p>必选参数不能跟在可选参数后边。</p>\n<p>对于声明的实例，此时是可以改动的：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let point = new Point(1, 2);\npoint.x = 3;</code></pre></div>\n<p>如何使实例化声明的参数不可改动呢？</p>\n<p>引入概念：access modifier</p>\n<p>Access modifiers (or access specifiers) are keywords in object-oriented languages that set the accessibility of classes, methods, and other members.</p>\n<p>Access modifiers are a specific part of programming language syntax used to facilitate the encapsulation of components.</p>\n<p>typescript中有三种：</p>\n<ul>\n<li>public //默认值</li>\n<li>private</li>\n<li>protected</li>\n</ul>\n做如下改动：\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">private x: number;\nprivate y: number;</code></pre></div>\n<p>则此时只能访问<code>point.draw()</code>，x和y不能访问</p>\n<p>typescript支持更简单的书写方式，上述代码可简化如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Point {\n    constructor(private x?: number, private y?: number){\n\n    }\n\n    draw(){\n    console.log(&#39;X: &#39; + this.x + &#39;, Y: &#39; + this.y);\n    }\n}\n\nlet point = new Point(1, 2);\npoint.draw();</code></pre></div>\n<p>那需要访问x，y的时候怎么办呢？</p>\n<p>可以添加如下method：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">getX() {\n    return this.x;\n}</code></pre></div>\n<p>然后调用<code>point.getX()</code>获取x的值。</p>\n<p>那需要重新设置x，y的值的时候怎么办呢？</p>\n<p>可以添加如下方法：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">setX(value){\n    if (value &lt; 0)\n    throw new Error(&#39;value cannot be less than 0.&#39;);\n    this.x = value;\n}</code></pre></div>\n<p>可以在此方法中设置一些逻辑，比如过滤不合法值。</p>\n<p>property</p>\n<p>将上述代码的形式做进一步转变：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Point {\n    constructor (private x?:number, private y?: number){\n\n    }\n\n    //getter\n    get X(){\n    return this.x;\n    }\n\n    //setter\n    set X(){\n    if (value &lt; 0)\n        throw new Error(&#39;value cannot be less than 0.&#39;)\n    this.x = value;\n    }\n\n    draw(){\n    console.log(&#39;X: &#39; + this.x + &#39;, Y: &#39; + this.y);\n    }\n}\n\n//实例化\nlet point = new Point(1, 2);\n//read\nlet x = point.X;\nconsole.log(&#39;X: &#39; + x);\n//set\npoint.X = 7;\npoint.draw();</code></pre></div>\n<p>此时X即为protperty。虽然其实质是method，但很像Field</p>\n<p>运行代码出现错误提示：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    error TS1056: Accessors are only available when targeting ECMAScript 5 and higher.</code></pre></div>\n<p>运行<code>tsc —target ES2016 main.ts</code></p>\n<p>命名规范一般采用第一个单词之后的每个单词首字母大写</p>\n<p>将大写X改为小写x，将构造器中的x前面加上一个下划线_</p>\n<p>最终版如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//定义\nclass Point {\n    constructor (private _x?:number, private _y?: number){\n\n    }\n\n    get x(){\n    return this._x;\n    }\n\n    set x(value){\n    if (value &lt; 0)\n        throw new Error(&#39;value cannot be less than 0.&#39;)\n    this._x = value;\n    }\n\n    draw(){\n    console.log(&#39;X: &#39; + this._x + &#39;, Y: &#39; + this._y);\n    }\n}\n\n//实例化\nlet point = new Point(1, 2);\n//read\nlet x = point.x;\nconsole.log(&#39;X: &#39; + x);\n//set\npoint.x = 7;\npoint.draw();</code></pre></div>\n<p>Fields should (almost always) be kept private to a class and accessed via get and set properties.</p>\n<p>Properties provide a level of abstraction allowing you to change the fields while not affecting the external way they are accessed by the things that use your class.</p>\n<p>module</p>\n<p>将之前创建的class的定义剪切至新文件./point.ts，在class前添加<code>export</code>导出。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">export class Point {\n\n}</code></pre></div>\n<p>在./mian.ts中导入Point类然后再进行调用</p>\n<p><code>import { Point } from ‘./point’</code>\n这里的module是typescript中的module，和angular中的module不是一个意思。</p>\n<p>此时在命令行调用会出错，我还不知为什么</p>","frontmatter":{"title":"","date":null}}},"pageContext":{"slug":"/29171212-typescript-intro/","previous":{"fields":{"slug":"/20180412-mysql-add-user/"},"frontmatter":{"title":"mysql添加用户"}},"next":{"fields":{"slug":"/开篇-自警/"},"frontmatter":{"title":""}}}}